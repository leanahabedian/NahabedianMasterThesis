\section{Resolviendo el problema de control LTS SGR(1)}

En esta sección explicaremos como una solución para un problema de control SGR(1) puede ser obtenida por construcción
utilizando técnicas existentes de síntesis de controladores (basados en estados), llamados GR(1). \cite{Piterman}

La construcción de la máquina para un problema de control LTS SGR(1) esta divido en dos pasos. Primero, se crea un juego GR(1)
$G$ en representación del ambiente $E$, las asunciones $A_s$, los objetivos $O$ y el conjunto de acciones controlables
$A_C$. Como segundo paso, se elabora una solución $(\sigma,u)$ al juego GR(1) para construir una máquina $M$ (i.e un
controlador LTS) para $\mathcal{E}$. Esta solución al problema de control LTS SGR(1) $\mathcal{E}$ existe, si y solo si,
existe una solución al juego GR(1) $G$. Luego, podremos afirmar que el controlador LTS $M$ creada a partir de
$(\sigma,u)$ es una solución a $\mathcal{E}$.

\subsection{Control LTS SGR(1) a juegos GR(1)}

Convertiremos el problema de control LTS SGR(1) a un juego GR(1). Dado un problema de control LTS SGR(1) $\mathcal{E} =
<E,H,A_C>$ construimos un juego GR(1) $G = (S_g,\Gamma^-,\Gamma^+,s_{g_0},\varphi_g)$ tal que cada estado en $S_g$
representa un estado en $E$ y una valuación de todos los flujos que aparecen en $A_s$ y en $G$.

Mas precisamente, y por la definición de control LTS SGR(1) (definición \ref{ControlLTSSGR1}) tendremos que $H =
\{(\emptyset,I),(A_s,G)\}$, $E = (S_e,A,\Delta_e,s_{e_0})$, $A_s = \bigwedge_{i=1}^n\Box\ \Diamond\ \phi_i$, $I = \Box\
\rho$ y $G = \bigwedge_{j=1}^m\Box\ \Diamond\ \omega_j$. Sea $fl = \{\dot1,...,\dotk\}$ un conjunto de flujos usados en
$A_s$ y en $G$ donde $\doti = <I_i,T_i,Init_i>$. Construimos al juego $G = (S_g,\Gamma^-,\Gamma^+,s_{g_0},\varphi_g)$ de
la siguiente manera.

Construimos $S_g$ a partir de $E$ de tal forma, que los estados en $S_g$ corresponden a un estado en $E$ y los valores
de verdad de los \emph{flujos} en $\varphi$. Formalmente, tenemos que  $S_g = S_e \times \prod_{i=1}^k\{true,false\}$.
Consideramos un estado $s_g = (s_e,\alpha_1,...,\alpha_k)$. Dado un flujo $fl_i$, diremos que $s_g$ satisface $fl_i$ si
$\alpha_i$ es $true$ y $s_g$ no satisface $fl_i$ si no. 

Además, definiremos las relaciones $\Gamma^-$ y $\Gamma^+$ aplicando las siguientes reglas. Sea $s_g =
(s_e,\alpha_1,...,\alpha_k)$. Si $s_g$ no satisface $\rho$ (es decir, $s_g$ es no seguro) no agregaremos los sucesores a
$s_g$. Si $s_g$ satisface $\rho$, por cada transición $(s_e,l,s_e') \in \Delta_e$ agregaremos
$(s_g,(s_e',\alpha_1',...,\alpha_k'))$ en $\Gamma^{\beta}$, donde $\beta$ y $\alpha_i'$ cumplen las siguiente
condiciones:

\begin{center}
\begin{tabular}{ c | c}
$\beta$ & $\alpha_i'$ \\
\hline
es +: si $l \in A_C$, & es $\alpha_i$: si $l \notin I_{fl_i} \cup T_{fl_i}$, \\
es -: si $l \notin A_C$. & es $true$: si $l \in I_{fl_i}$ o \\
& es $false$: si $l \in T_{fl_i}$. \\
\end{tabular}
\end{center}

El estado inicial $s_{g_0}$ es $(s_{e_0},initially_1,...,initially_k)$.

Por último, construiremos la \emph{condición de ganada} $\varphi_g$, definida como un conjunto infinito de trazas, para
$A_S$ y $G$ de la siguiente manera: abusando de la notación denotaremos $\phi_i$ al conjunto de estados $s_g$ tales que
$s_g$ satisface las asunciones $\phi_i$ y a $\gamma_i$ al conjunto de secuencias que satisfacen
$gr((\phi_1,..,\phi_n),(\gamma_1,...,\gamma_m))$. De esta forma, obtendremos que $G = (S_g,\Gamma^-,\Gamma^+,s_{g_0},\varphi_g)$ es un
juego GR(1).

Cabe destacar que las propiedades de seguridad (safety) que son parte de la especificación no están contempladas en la
\emph{condición de ganada} $\varphi_g$ del juego GR(1), pero si se traducen a un problema de \emph{deadlock avoidance} a
la hora de construir $\Gamma^-$ y $\Gamma^+$. De esta manera, la \emph{condicion de ganada} es  $\Box\ \rho
\wedge(\bigwedge_{i=1}^n\Box\Diamond\phi_i \Rightarrow \bigwedge_{j=1}^m \Box\Diamond\omega_j)$.

\subsection{Traduciendo la estrategia a un Controlador LTS}

ESCRIBIR AHORA ACA!!

\subsection{Algoritmo}

algoritmo
