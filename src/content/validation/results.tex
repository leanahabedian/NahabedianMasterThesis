\section{Resultados}

En esta sección detallaremos los resultados obtenidos para cada caso de estudio planteado en la sección
\ref{cases_of_study}. Para comparar diferentes resultados obtenidos por el problema de control notaremos $Tr(C)$ como el
conjunto de trazas del LTS $C$. Informalmente, una traza es una secuencia de acciones que un controlador puede
realizar. Por lo tanto, dado dos controladores $C_1$, $C_2$, si toda traza de $C_1$ está en $Tr(C_2)$ (i.e. $Tr(C_1) \subset
Tr(C_2)$) podremos decir que el controlador $C_2$ tiene más comportamiento que $C_1$ debido a que en el controlador
$C_2$ puedo ejecutar todas las secuencias de acciones de $C_1$ y algunas más.

\subsection{Planta de energía nuclear}

Nosotros resolvemos tres diferentes problemas de control de actualización dinámica de controladores para este caso de
estudio. El primero no tiene requerimientos para el período de transición entre la especificación vieja y la nueva (esto
es, $T$ configurado como $true$). El controlador obtenido ($C^1_u$) exhibe el comportamiento invalido descrito en
\cite{PanzicaLaManna:2013:FCC:2487336.2487349}, permitiendo una actualización mientras la bomba esta apagada, prendiendo
la bomba durante la transición y permitiendo al nuevo controlador a nunca reiniciarla.

El segundo problema de control usa a $T$ con el requerimiento genérico de \cite{6224401} (ver fórmula
\ref{ghezzi_formula}). El controlador resultante ($C^2_u$) evita la actualización mientras la bomba esta apagada, y por
lo
tanto, evita que el nuevo controlador deje la bomba apagada sin intención. De hecho, como se espera, este controlador
exhibe estrictamente menos comportamiento que el controlador previo ($Tr(C^2_u) \subset Tr(C^1_u)$).

Finalmente, el tercer problema de control modela explícitamente el requerimiento de que la bomba no debería estar
apagada continuamente (esto es, en realidad, un requerimiento de transición de aceptación Büchi que puede ser manejado
por nuestro enfoque sin problemas. Ver capítulo \ref{discusion}). El controlador resultante ($C^3_u$) no sólo evita el
escenario descrito en \cite{PanzicaLaManna:2013:FCC:2487336.2487349} y exhibe menos comportamiento que el primer
controlador ($Tr(C^2_u) \subset Tr(C^1_u)$) sino que también provee más oportunidades de actualización que el segundo
controlador exhibiendo estrictamente más comportamiento ($Tr(C^2_u) \subset Tr(C^3_u)$). 

En otras palabras, nuestra técnica provee un criterio más relajado para controladores actualizables con respecto a
\cite{6224401} y que a su vez, es correcto por construcción ya que satisface los requerimientos de transición y además
no necesita de una validación manual posterior como en \cite{PanzicaLaManna:2013:FCC:2487336.2487349}.

\subsection{RailCab}

Como en el caso de estudio previo, resolvimos tres problemas de control de actualización dinámica distintos. El primero
sin requerimientos para la transición entre la vieja especificación y la nueva (i.e. $T = true$). El controlador
resultante $C^1_u$ ....

\subsection{Buscador UAV de vida salvaje}

Utilizamos este caso de estudio, como ejemplo concreto de que los requerimientos de transición $T$ son fuertemente
necesarios. Como dijimos previamente, no hay salto trivial entre la especificación vieja y la especificación nueva. Esto
se debe a que el UAV en nuestra especificación del problema solo puede volar en tres posiciones, $high$, $mid$ y $low$,
que representan las tres franjas descritas en el caso de estudio. (i.e. entre 40 a 50 metros, entre 30 a 40 metros y
entre 20 a 30 metros). Por lo tanto, es necesario en este caso de estudio, definir $T$ como $\Box\ (startNewSpec
\rightarrow FlyingLow)$ donde $FlyingLow$ es el flujo definido de la siguiente manera: $FlyingLow = \langle
\{low\},\{high,mid\},\bot\rangle$. 

Mediante esta fórmula FLTL estamos pidiendo que el controlador resultante, luego de la síntesis, cumpla con la propiedad
de que la acción $startNewSpec$ sea disparada, solo si en ese momento el flujo $FlyingLow$ esta prendido, es decir,
si el UAV esta volando en la franja de 20 a 30 metros. De no configurar dicho requerimiento de transición, la
actualización no podría efectuarse nunca, puesto que cuando el evento $startNewSpec$ suceda, si el UAV se encuentra en
una altura distinta, la especificación nueva $G'$ no podrá ser garantizada.

Así mismo, podríamos querer una actualización más restrictiva y por lo tanto más controlada configurando requerimientos
más fuertes en $T$. Por ejemplo, agregando el requerimiento de transición de que si la actualización se realiza al
momento en que vida salvaje ha sido detectada, forzar a que el UAV deba hacer $follow$ de dicho animal. De no agregar
dicha configuración, el UAV

\subsection{Production Cell}

Para analizar este caso, exploramos varios escenarios de adaptación definiendo una especificación inicial y nueva. Para
cada escenario identificamos posibles especificaciones alternativas. Por ejemplo, una decisión común para todo escenario
de actualización es como son los productos procesados. ?`Debería la cadena de montaje estar vacía antes de que se
produzca la actualización? En este caso, los productos que están siendo procesados al momento en que la actualización es
requerida ?`deberían ser descartados? ?`o terminarlos? Si decidimos terminarlos, ?`los deberíamos terminar con la vieja
especificación o con la nueva? O tal vez, durante el proceso de transición, la cadena de montaje no necesita ser vaciada
y no importa que receta se lleva a cabo para construir un producto, siempre y cuando, estén construidos de una manera
consistente. 

Estas alternativas fueron modeladas cambiando el valor del requerimiento de transición $T$...

\subsection{Cuadcóptero}

Un aspecto interesante del controlador resultante, en este caso de estudio, es que en la vieja especificación el nivel
de batería nunca es tenido en cuenta, generando en el ambiente de actualización $E_u$ mucho no determinismo a la hora de
efectuar la acción $startNewSpec$ desde cualquier estado de $E$ (i.e. una transición por cada nivel de batería distinto que
puede tener el nuevo ambiente). A pesar del no determinismo que este problema de control tiene al cambiar la
especificación, el controlador de actualización simplemente carga la batería inmediatamente después de que se efectúe la
actualización (i.e. cuando $startNewSpec$ ocurre). Esto sucede debido a que el controlador de actualización obtenido
asume una actualización en el peor caso, que es cuando no hay batería disponible en el robot.

Por otra parte, Pudimos validar el comportamiento del drone tras observar mediante la herramienta MTSA como los estados
del controlador de actualización eran recorridos, y a su vez, observar las acciones reales que el robot efectuaba. La
única acción controlada por el operador del sistema vía MTSA fue $beginUpdate$. Un video con uno de estos experimientos
puede ser visto en \url{https://www.youtube.com/watch?v=dFgFnu9y10M}.


